<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>Workers - MZBench Docs</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/custom.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">MZBench Docs</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Overview</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Scenarios <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../scenarios/tutorial/">How to Write a Scenario</a>
</li>

                        
                            
<li >
    <a href="../scenarios/spec/">Scenario DSL Specification</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li >
                        <a href="../dashboard/">Dashboard</a>
                    </li>
                
                
                
                    <li >
                        <a href="../cli/">CLI</a>
                    </li>
                
                
                
                    <li >
                        <a href="../api/">API</a>
                    </li>
                
                
                
                    <li >
                        <a href="../deployment/">Deployment</a>
                    </li>
                
                
                
                    <li >
                        <a href="../cloud_plugins/">Cloud Plugins</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">Workers</a>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../cloud_plugins/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li class="disabled">
                        <a rel="prev" >
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
                    <li>
                        <a href="http://github.com/machinezone/mzbench/">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#how-to-write-a-worker">How to Write a Worker</a></li>
        
            <li><a href="#command-line-utilities">Command Line Utilities</a></li>
        
            <li><a href="#how-to-write-an-erlang-worker">How to write an Erlang worker</a></li>
        
            <li><a href="#how-to-write-a-python-worker">How to write a Python worker</a></li>
        
            <li><a href="#importing-external-metrics">Importing external metrics</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p>To benchmark a particular protocol or service, MZBench uses a matching <em>worker</em>.</p>
<p><strong>Worker</strong> is a library of <a href="../scenarios/spec/">statements</a> to access a particular service and collect statistics about its usage. MZBench ships with workers for HTTP and XMPP protocols and a worker that executes console commands, and in many cases they are enough. But if you need to test a specific service, you&rsquo;ll probably need to write a worker for it.</p>
<p>A <strong>worker</strong> can be implemented in either <a href="#how-to-write-an-erlang-worker">Erlang</a> or <a href="#how-to-write-a-python-worker">Python</a> programming languages. Please note that the support for Erlang programming language is a little bit more complete.</p>
<h1 id="how-to-write-a-worker">How to Write a Worker<a class="headerlink" href="#how-to-write-a-worker" title="Permanent link">&para;</a></h1>
<h2 id="command-line-utilities">Command Line Utilities<a class="headerlink" href="#command-line-utilities" title="Permanent link">&para;</a></h2>
<p>MZBench distribution provides <a href="../cli/">command line utilities</a> to assist you during your development effort.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All command examples below are executed in the MZBench directory. To run them from a different location, specify the full path to MZBench:</p>
<pre><code>$ /path/to/mzbench/bin/mzbench
</code></pre>
</div>
<h3 id="generate">Generate<a class="headerlink" href="#generate" title="Permanent link">&para;</a></h3>
<p>First, generate an <em>Erlang</em> empty worker application with <a href="../cli/#new_worker"><code>new_worker</code></a>:</p>
<pre><code class="bash">$ ./bin/mzbench new_worker &lt;worker_name&gt;
</code></pre>

<p>It creates a new directory <code>&lt;worker_name&gt;</code> with a minimalistic but fully functional MZBench worker named <code>&lt;worker_name&gt;</code>. Particularly interesting files are <code>src/&lt;worker_name&gt;.erl</code>, which holds the worker source code, and <code>examples/&lt;worker_name&gt;.erl</code>, which contains a simple MZBench <a href="../scenarios/spec/">scenario</a> using it.</p>
<p>If the worker you develop works over a common protocol like TCP or you wish to develop it using a different programming language, the <code>new_worker</code> command can generate your a more elaborate worker already containing the usual boilerplate code for this type of services. List available protocol templates with <a href="../cli/#list_templates"><code>list_templates</code></a>:</p>
<pre><code class="bash">$ ./bin/mzbench list_templates
</code></pre>

<p>Then generate your worker with the additional <code>--template</code> parameter:</p>
<pre><code class="bash">$ ./bin/mzbench new_worker --template &lt;protocol&gt; &lt;worker_name&gt;
</code></pre>

<p>For instance, you can generate a <em>Python</em> based worker using the following command:</p>
<pre><code class="bash">$ ./bin/mzbench new_worker --template python_empty &lt;worker_name&gt;
</code></pre>

<p>The worker entry point is contained in the file <code>src/&lt;worker_name&gt;.py</code> in this case.</p>
<h3 id="compile-and-debug">Compile and Debug<a class="headerlink" href="#compile-and-debug" title="Permanent link">&para;</a></h3>
<p>MZBench lets you quickly build a worker and launch a local instance of a benchmarking scenario without running a server.</p>
<p>In the worker directory, run <a href="../cli/#run_local"><code>run_local &lt;script&gt;</code></a>, where <code>&lt;script&gt;</code> is the path to the scenario to run:</p>
<pre><code class="bash">$ ./bin/mzbench run_local &lt;script&gt;
</code></pre>

<p>You can define environment variables with the <code>--env</code> option.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All <a href="../scenarios/spec/#make_install"><code>make_install</code></a> top-level statements are ignored in this execution mode.</p>
</div>
<h3 id="execute">Execute<a class="headerlink" href="#execute" title="Permanent link">&para;</a></h3>
<p>After debugging, test the worker with a real MZBench server and real cloud nodes. To make it installable on MZBench nodes, specify the worker&rsquo;s git address in your benchmark scenario with <a href="../scenarios/spec/#make_install"><code>make_install(git = &lt;URL&gt;, branch = &lt;Branch&gt;, dir = &lt;Dir&gt;)</code></a>.</p>
<p><a href="https://github.com/machinezone/mzbench/blob/master/workers/simple_http/src/simple_http_worker.erl">Simple HTTP worker example →</a></p>
<h2 id="how-to-write-an-erlang-worker">How to write an Erlang worker<a class="headerlink" href="#how-to-write-an-erlang-worker" title="Permanent link">&para;</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You need basic Erlang knowledge to understand this tutorial. Refer to <a href="http://www.erlang.org/doc/getting_started/users_guide.html">Getting Started with Erlang User&rsquo;s Guide</a> or to the <a href="http://learnyousomeerlang.com">Learn You Some Erlang for great good!</a> book for an introduction to Erlang.</p>
</div>
<h3 id="the-erlang-worker-structure">The Erlang Worker Structure<a class="headerlink" href="#the-erlang-worker-structure" title="Permanent link">&para;</a></h3>
<p>A worker provides DSL statements and metrics. The statements need not to be independent as the worker can have internal state.</p>
<p>To understand the general structure of a worker, let&rsquo;s see the source code of the <code>simple_http_worker</code> provided with the MZBench distribution:</p>
<pre><code class="erlang">-module(simple_http_worker).

-export([initial_state/0, metrics/0,
         get/3]).

initial_state() -&gt; [].

metrics() -&gt;
    [
        {group, &quot;Summary&quot;, [
            {graph, #{title =&gt; &quot;HTTP Response&quot;,
                      units =&gt; &quot;N&quot;,
                      metrics =&gt; [{&quot;http_ok&quot;, counter}, {&quot;http_fail&quot;, counter}, {&quot;other_fail&quot;, counter}]}},
            {graph, #{title =&gt; &quot;Latency&quot;,
                      units =&gt; &quot;microseconds&quot;,
                      metrics =&gt; [{&quot;latency&quot;, histogram}]}}
        ]}
    ].

get(State, _Meta, URL) -&gt;
    StartTime = os:timestamp(),
    Response = hackney:request(get, list_to_binary(URL), [], &lt;&lt;&quot;&quot;&gt;&gt;, []),

    case Response of
        {ok, _, _, BodyRef} -&gt; hackney:skip_body(BodyRef);
        _ -&gt; ok
    end,

    Latency = timer:now_diff(os:timestamp(), StartTime),
    mzb_metrics:notify({&quot;latency&quot;, histogram}, Latency),

    case Response of
        {ok, 200, _, _} -&gt;
            mzb_metrics:notify({&quot;http_ok&quot;, counter}, 1);
        {ok, _, _, _} = Reply -&gt;
            lager:error(&quot;GET failed: ~p&quot;, [Reply]),
            mzb_metrics:notify({&quot;http_fail&quot;, counter}, 1);
        E -&gt;
            lager:error(&quot;hackney:request failed: ~p&quot;, [E]),
            mzb_metrics:notify({&quot;other_fail&quot;, counter}, 1)
    end,
    {nil, State}.
</code></pre>

<p>It exports three functions: <code>initial_state/0</code>, <code>metrics/0</code>, and <code>get/3</code>. The first two are mandatory for any worker. </p>
<dl>
<dt><code>initial_state/0</code></dt>
<dd>Set the worker&rsquo;s initial state. Each parallel job has its own state, so this function will be called once per job start.</dd>
<dt><code>metrics/0</code></dt>
<dd>Return a group of metrics generated by this worker. <a href="#declaring-metrics">Declaring Metrics</a>.</dd>
</dl>
<p>The rest of the exported functions define the BDL statements provided by this worker. You can, of course, provide none, although such a worker wouldn&rsquo;t be very useful. The <code>simple_http_worker</code>, for instance, provides the <code>get</code> statement to fetch particular HTTP document.</p>
<h3 id="how-to-define-statements">How to Define Statements<a class="headerlink" href="#how-to-define-statements" title="Permanent link">&para;</a></h3>
<p>To define a BDL statement provided by your worker, export an Erlang function that will be called when this statement is encountered:</p>
<pre><code class="erlang">&lt;statement_name&gt;(State, Meta, [&lt;Param1&gt;, [&lt;Param2&gt;, ...]]) -&gt;
    {ReturnValue, NewState}.
</code></pre>

<p>The function has the same name as the statement it defines. It accepts at least two parameters: the worker internal state at the moment the statement is executed and <em>meta</em> information proplist. The function can also accept any number of other parameters. They correspond to the parameters of the statement.</p>
<p>For example, this function:</p>
<pre><code class="erlang">foo(State, Meta, X, Y) -&gt;
    {nil, State}.
</code></pre>

<p>is called as <code>foo(X, Y)</code> from a benchmarking scenario.</p>
<p>If you want to use key arguments at your function call as <code>foo(x = 1, y = 2)</code>, you need to declare three argument function foo and expect third parameter to be <a href="http://erlang.org/doc/man/proplists.html">proplist</a>. For example:</p>
<pre><code class="erlang">foo(State, Meta, Proplist) -&gt;
    1 = proplists:get_value(x, Proplist),
    2 = proplists:get_value(y, Proplist),
    {nil, State}.
</code></pre>

<p>The statement function must return a tuple of two values:</p>
<ul>
<li>the return value of statement; return <code>nil</code> if your statement has no return value</li>
<li>the next worker state</li>
</ul>
<p>Statements are processed sequentially; each statement receives the state from the previous one and passes it further.</p>
<p>Two exceptions are the statements within the <a href="../scenarios/spec/#parallel_1"><code>parallel</code></a> section and iterations within a <code>loop</code> with <a href="../scenarios/spec/#parallel">parallel &gt; 1</a>. In these cases the statements within the same thread share the same sequence of statements, which parallel threads don&rsquo;t. The final state of the whole <code>parallel</code> or <code>loop</code> statement is the one from the first &ldquo;thread&rdquo;; other threads&rsquo; states don&rsquo;t affect the final state.</p>
<h3 id="metrics">Metrics<a class="headerlink" href="#metrics" title="Permanent link">&para;</a></h3>
<p>Metrics are numerical values collected during the scenario execution. They are the main result of your worker and represent the values you want to evaluate with your benchmark.</p>
<h4 id="metric-types">Metric Types<a class="headerlink" href="#metric-types" title="Permanent link">&para;</a></h4>
<p>MZBench currently support four types of metrics:</p>
<dl>
<dt><code>counter</code></dt>
<dd>A single additive value. New values are simply added to the current one.</dd>
<dt><code>gauge</code></dt>
<dd>A single non-additive value. New value replaces the previous one.</dd>
<dt><code>histogram</code></dt>
<dd>A set of numerical values that quantify a distribution of values. New values are added to the distribution.</dd>
<dt><code>derived</code></dt>
<dd>Evaluated periodically using user-defined function based on another metric values. <a href="#derived-metrics">Learn more</a>.</dd>
</dl>
<p>For example, if you are consuming TCP packets of various sizes and you want to track overall amount of data being transferred, use <code>counter</code>. If you are interested in its distribution–mean size, 50 percentile, and so on–you need a <code>histogram</code>.</p>
<h4 id="declaring-metrics">Declaring Metrics<a class="headerlink" href="#declaring-metrics" title="Permanent link">&para;</a></h4>
<p>Declare the groups of metrics collected by your worker in the list returned by <code>metrics/0</code>. Each group corresponds to a structure with following spec:</p>
<pre><code>graph_group() :: {group, Name :: string(), [graph()]}
               | graph().
graph()       :: {graph, Opts :: #{metrics =&gt; [metric()],
                                   units =&gt; string(),
                                   title =&gt; string()}}
               | [metric()]
               | metric().
metric()      :: {Name :: string(), Type :: metric_type() }
               | {Name :: string(), Type :: metric_type(), Opts :: map()}.
metric_type() :: counter | gauge | histogram.
</code></pre>

<p>This structure has a three-level hierarchy:</p>
<ul>
<li>Group of graphs is placed on the top of this hierarchy. It consists of one or more graphs and defines a group of graphs under the same name.</li>
<li>Graph consists of one or more metrics that will be plotted on the same chart. Furthermore, you could specify additional options for the chart: units, title, etc.</li>
<li>Metric is the lowest unit of this hierarchy. It specifies the name and type of the user-defined metric.</li>
</ul>
<p>Let&rsquo;s see the following metrics declaration:</p>
<pre><code>metrics() -&gt; [{group, &quot;HTTP Requests&quot;, [
                {graph, #{metrics =&gt; [{&quot;success_requests&quot;, counter}, {&quot;failed_requests&quot;, counter}]}},
                {graph, #{title =&gt; &quot;Request's latency&quot;,
                          units =&gt; &quot;ms&quot;,
                          metrics =&gt; [{&quot;latency&quot;, histogram}]}}]}].
</code></pre>

<p>In this example, a group of graphs with the name &ldquo;HTTP Requests&rdquo; is created. It consists of several graphs representing the number of successful and failed requests and the request latencies.</p>
<p>A graph can produce several charts. In the example above, the graph for successful and failed request produces two charts: absolute counters and their rps.</p>
<h4 id="dynamic-metrics-declaration">Dynamic metrics declaration<a class="headerlink" href="#dynamic-metrics-declaration" title="Permanent link">&para;</a></h4>
<p>Metrics could be also declared during the bench run:</p>
<pre><code>mzb_metrics:declare_metrics([{group, &quot;HTTP Requests&quot;, [
                {graph, #{metrics =&gt; [{&quot;success_requests&quot;, counter}, {&quot;failed_requests&quot;, counter}]}},
                {graph, #{title =&gt; &quot;Request's latency&quot;,
                          units =&gt; &quot;ms&quot;,
                          metrics =&gt; [{&quot;latency&quot;, histogram}]}}]}]).
</code></pre>

<p>This feature is useful if your metric set depends on some external conditions or script configuration.</p>
<h4 id="derived-metrics">Derived Metrics<a class="headerlink" href="#derived-metrics" title="Permanent link">&para;</a></h4>
<p>Derived metrics are basically gauges which are evaluated on the director node every ~10sec. To define a derived metric, specify the <code>resolver</code> function in the metric opts dictionary. This function is used to evaluate the metric value.</p>
<p>Typical example of a derived metric is the current number of pending requests. We specify a function (<code>pending_requests</code>) to calculate the metric value in the metric options and then define the function as simple difference between the number of sent requests and received responses:</p>
<pre><code class="erlang">metrics() -&gt; [{group, &quot;Requests&quot;, [
                {graph, #{metrics =&gt; [
                    {&quot;requests_sent&quot;, counter},
                    {&quot;responses_received&quot;, counter},
                    {&quot;pending_requests&quot;, derived, #{resolver =&gt; pending_requests}}]}},
                ]}].

pending_requests() -&gt;
    mzb_metrics:get_value(&quot;requests_sent&quot;) - mzb_metrics:get_value(&quot;responses_received&quot;).
</code></pre>

<h4 id="hooks">Hooks<a class="headerlink" href="#hooks" title="Permanent link">&para;</a></h4>
<p><a href="../scenarios/spec/#pre_hook-and-post_hook">Pre and post hooks</a> let you run custom code before and after a benchmark. Hooks can be applied on every node or only on the director node. You can change any environment variable in your hook handler and use it in your scenario.</p>
<p>Scenario:</p>
<pre><code class="python">pre_hook():
    exec(all, &quot;yum install mylib&quot;)
    worker_call(fetch_url, simple_http_worker)

pool(size = 3, worker_type = simple_http_worker):
    loop(time = 1 sec,
         rate = ramp(linear, 10 rps, 50 rps)):
        get(var(&quot;url&quot;, &quot;http://mydomain.com&quot;))
</code></pre>

<p>Worker:</p>
<pre><code class="erlang">fetch_url(Env) -&gt;
    {ok, [{&quot;url&quot;, &quot;http://mycdn.com/myresource&quot;} | Env]}.
</code></pre>

<h3 id="updating-metrics">Updating Metrics<a class="headerlink" href="#updating-metrics" title="Permanent link">&para;</a></h3>
<p>You can update a metric from anywhere inside your worker. Simply call the following function:</p>
<pre><code class="erlang">mzb_metrics:notify({&quot;&lt;metric_name&gt;&quot;, &lt;metric_type&gt;}, &lt;value&gt;)
</code></pre>

<p>The tuple <code>{"&lt;metric_name&gt;", &lt;metric_type&gt;}</code> is the same that was used during the metric declaration and identifies the metric to update. <code>&lt;value&gt;</code> is the value to add to the metric.</p>
<h2 id="how-to-write-a-python-worker">How to write a Python worker<a class="headerlink" href="#how-to-write-a-python-worker" title="Permanent link">&para;</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You need a basic knowledge about the Python programming language to understand this tutorial. Refer to <a href="https://docs.python.org/2.7/tutorial/index.html">The Python Tutorial</a> for an introduction to Python.</p>
</div>
<h3 id="the-python-worker-structure">The Python Worker Structure<a class="headerlink" href="#the-python-worker-structure" title="Permanent link">&para;</a></h3>
<p>A worker provides DSL statements and metrics. The statements need not to be independent as the worker can have internal state.</p>
<p>To understand the general structure of a worker, let&rsquo;s see the source code of the <code>python_empty</code> worker template provided with the MZBench distribution:</p>
<pre><code class="python">import random
import mzbench

def initial_state():
    pass


def metrics():
    return [
        [
            ('print', 'counter'),
            ('print_2', 'counter')
        ],
        ('dummy', 'histogram')
    ]


def my_print(msg):
    mzbench.notify(('print', 'counter'), 1)
    mzbench.notify(('print_2', 'counter'), 2)

    print &quot;{0}&quot;.format(msg)

    mzbench.notify(('dummy', 'histogram'), random.uniform(0, 1000000000)/7)
</code></pre>

<p>It contains three functions: <code>initial_state()</code>, <code>metrics()</code>, and <code>my_print()</code>. The first two are mandatory for any worker. </p>
<dl>
<dt><code>initial_state()</code></dt>
<dd>Useful to initialize the worker&rsquo;s initial state. Each parallel job has its own separate Python interpreter process, so this function will be called once per job start.</dd>
<dt><code>metrics()</code></dt>
<dd>Return a group of metrics generated by this worker. <a href="#declaring-metrics-in-python">Declaring Metrics in Python</a>.</dd>
</dl>
<p>The rest of the exported functions define the DSL statements provided by this worker. You can, of course, provide none, although such a worker wouldn&rsquo;t be very useful. The <code>python_empty</code> worker, for instance, provides the <code>my_print</code> statement to output a string to the standard output.</p>
<h3 id="how-to-define-statements_1">How to Define Statements<a class="headerlink" href="#how-to-define-statements_1" title="Permanent link">&para;</a></h3>
<p>To define a DSL statement provided by your worker, write a Python function that will be called when this statement is encountered:</p>
<pre><code class="python">def &lt;statement_name&gt;([&lt;Param1&gt;, [&lt;Param2&gt;, ...]]):
    [return &lt;ReturnValue&gt;]
</code></pre>

<p>The function has the same name as the statement it defines. It can accept any number of parameters, they correspond to the parameters of the statement.</p>
<p>For example, this function:</p>
<pre><code class="python">def foo(X, Y):
    pass
</code></pre>

<p>is called as <code>foo(X, Y)</code> from a benchmarking scenario.</p>
<p>The statement function may return a value corresponding to the return value of the statement or nothing if the statement has no return value.</p>
<p>Statements are processed sequentially in the same interpreter, so the values of the global variables are conserved between calls.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please beware that the <a href="../scenarios/spec/#parallel_1"><code>parallel</code></a> section and <a href="../scenarios/spec/#parallel">parallel &gt; 1</a> option of the <code>loop</code> 
can&rsquo;t and shouldn&rsquo;t be used with the Python based workers.</p>
</div>
<h3 id="metrics_1">Metrics<a class="headerlink" href="#metrics_1" title="Permanent link">&para;</a></h3>
<p>Metrics are numerical values collected during the scenario execution. They are the main result of your worker and represent the values you want to evaluate with your benchmark.</p>
<h4 id="metric-types_1">Metric Types<a class="headerlink" href="#metric-types_1" title="Permanent link">&para;</a></h4>
<p>MZBench currently support three types of metrics with the Python based workers:</p>
<dl>
<dt><code>counter</code></dt>
<dd>A single additive value. New values are simply added to the current one.</dd>
<dt><code>gauge</code></dt>
<dd>A single non-additive value. New value replaces the previous one.</dd>
<dt><code>histogram</code></dt>
<dd>A set of numerical values that quantify a distribution of values. New values are added to the distribution.</dd>
</dl>
<p>For example, if you are consuming TCP packets of various sizes and you want to track overall amount of data being transferred, use <code>counter</code>. If you are interested in its distribution–mean size, 50 percentile, and so on–you need a <code>histogram</code>.</p>
<h4 id="declaring-metrics-in-python">Declaring Metrics in Python<a class="headerlink" href="#declaring-metrics-in-python" title="Permanent link">&para;</a></h4>
<p>Declare the metrics and the groups of metrics collected by your worker in the list returned by the <code>metrics()</code> function. Each metric is a tuple <code>(&lt;Name&gt;, &lt;Type&gt;)</code> where <code>&lt;Name&gt;</code> is the name of the metric and <code>&lt;Type&gt;</code> is the metric type. Each group is a list of metrics tuples. A group corresponds to metrics that will be plotted on the same chart.</p>
<p>Let&rsquo;s see the following metrics declaration:</p>
<pre><code class="python">def metrics():
    return [
        [
            ('print', 'counter'),
            ('print_2', 'counter')
        ],
        ('dummy', 'histogram')
    ]
</code></pre>

<p>In this example, three metrics are declared. <code>print</code> and <code>print_2</code> are <em>counters</em> and <code>dummy</code> is a <em>histogram</em>. Moreover, the metrics <code>print</code> and <code>print_2</code> will be plotted on the same graph.</p>
<h3 id="updating-metrics_1">Updating Metrics<a class="headerlink" href="#updating-metrics_1" title="Permanent link">&para;</a></h3>
<p>You can update a metric from anywhere inside your worker. Simply call the following function:</p>
<pre><code class="python">mzbench.notify(('&lt;metric_name&gt;', '&lt;metric_type&gt;'), &lt;value&gt;)
</code></pre>

<p>The tuple <code>('&lt;metric_name&gt;', '&lt;metric_type&gt;')</code> is the same that was used during the metric declaration and identifies the metric to update. <code>&lt;value&gt;</code> is the value to add to the metric.</p>
<h2 id="importing-external-metrics">Importing external metrics<a class="headerlink" href="#importing-external-metrics" title="Permanent link">&para;</a></h2>
<p>It could be useful to have an external data at MZBench dashboard. For this purpose a worker could fetch metrics from outside or implement statsd server and push all the data to MZBench API server. Please refer to <a href="https://github.com/machinezone/mzbench/blob/master/workers/tcpkali/src/tcpkali_worker.erl">tcpkali</a> worker code as an example.</p></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
